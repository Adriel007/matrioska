# Matrioska - LLM Orchestration System with Shared State

![Matrioska](https://live.staticflickr.com/8646/16075618524_6f3b5b199e_b.jpg)

## ğŸ“‹ Overview

**Matrioska** is an advanced orchestration system for large language models (LLMs) that implements a modular architecture with shared state. Inspired by the concept of Russian nesting dolls, the system decomposes complex tasks into specialized modules that communicate through a shared whiteboard.
*Google Colab link: [Here](https://colab.research.google.com/drive/14LHFEkI6isWJWtGZwnjeUl66SVf6YoT3)*

## ğŸ¯ Key Features

* **ğŸ§© Architectural Decomposition**: Automatically divides complex tasks into specialized modules
* **ğŸ§  Shared State**: Enables inter-module communication via `shared_state`
* **ğŸ’¾ Context Persistence**: Saves and restores progress between executions
* **âš¡ Hyperfocus Execution**: Each module operates with a specific focus
* **ğŸ”— Intelligent Integration**: Combines artifacts while maintaining consistency
* **â³ Simplicity and Reuse**: Aims to produce lightweight code and leverage CDNs/libraries

## ğŸ—ï¸ Architecture

### Main Components

1. **`LocalLLM`** â€“ Wrapper for Mistral models with 4-bit quantization
2. **`MatrioskaOrchestrator`** â€“ Main orchestrator of the pipeline
3. **`ContextManager`** â€“ Handles state management and persistence
4. **`Architecture`** â€“ Data structure for modular planning

### Execution Flow

```
PHASE 1: ARCHITECTURE â†’ PHASE 2: EXECUTION â†’ PHASE 3: ASSEMBLY
    â†“                         â†“                      â†“
 Decomposition         Modular Execution      Final Integration
```

## ğŸš€ How to Use

### Installation

```bash
pip install transformers accelerate bitsandbytes torch sentencepiece protobuf
```

### Basic Execution

```python
from matrioska import LocalLLM, MatrioskaOrchestrator

# Initialize model
llm = LocalLLM("mistralai/Mistral-7B-Instruct-v0.3")
orchestrator = MatrioskaOrchestrator(llm, base_path="/content")

# Run task
result = orchestrator.run("Create a library management system with dashboard")
```

### Directory Structure

```
/content/
â”œâ”€â”€ matrioska_artifacts/     # Artifacts generated by each module
â”œâ”€â”€ matrioska_checkpoints/   # Shared state and architecture
â”‚   â”œâ”€â”€ shared_state.json    # Shared whiteboard
â”‚   â””â”€â”€ architecture.json    # Architectural plan
â””â”€â”€ matrioska_results.zip    # Downloadable results
```

## ğŸ“– Module System

### Module Specification

```python
@dataclass
class ModuleSpec:
    id: str                    # Unique identifier
    name: str                  # Descriptive name
    description: str           # Functional description
    inputs: str                # Input dependencies
    outputs: str               # Expected outputs
    dependencies: List[str]    # Predecessor modules
    rules: str                 # Specific rules
    shared_state_reads: List[str]  # Keys to read
    shared_state_writes: List[str] # Keys to write
```

### Communication Example

```python
# Module A generates IDs
shared_state_updates = {
    "element_ids": ["#loginForm", "#bookList", "#dashboardStats"],
    "page_structure": {"login": "...", "catalog": "..."}
}

# Module B consumes IDs
context = context_manager.get_shared_context(["element_ids"])
```

## ğŸ”§ Model Configuration

### 4-bit Quantization

```python
quant_config = BitsAndBytesConfig(
    load_in_4bit=True,
    bnb_4bit_compute_dtype=torch.float16,
    bnb_4bit_use_double_quant=True,
    bnb_4bit_quant_type="nf4"
)
```

### Generation Parameters

* **max_tokens**: 4000
* **temperature**: 0.3
* **top_p**: 0.85
* **do_sample**: True

## ğŸ“Š Architecture Prompt

The system uses a specialized prompt (`ARCHITECT_SYSTEM_PROMPT`) to decompose tasks, defining:

* **General project objective**
* **Specialized modules** with dependencies
* **Communication contracts** via shared_state
* **Specific manuals** for each module

## ğŸ’¡ Use Cases

### Web Development

```python
result = orchestrator.run('''
Create a React application with:
- JWT authentication
- Product CRUD
- Admin dashboard
- Responsive design
''')
```

### Data Processing

```python
result = orchestrator.run('''
Data analysis system with:
- REST API extraction
- Cleaning and transformation
- Interactive visualizations
- Automated reports
''')
```

## ğŸ¨ Example Output

```
ğŸª† MATRIOSKA ORCHESTRATOR - Hyperfocus + SharedState
================================================================================

ğŸ—ï¸  PHASE 1: ARCHITECTURE
--------------------------------------------------------------------------------
ğŸ“‹ Task: 'Library management system with dashboard'

âœ“ Project: Library Management System
âœ“ Goal: Create a complete library management system with authentication, CRUD, and dashboard
âœ“ Modules: 3
   1. HTML Structure ğŸ“–[] âœï¸['element_ids', 'page_structure']
   2. CSS Styling ğŸ“–['element_ids', 'page_structure'] âœï¸['css_classes', 'color_scheme']
   3. Authentication Logic ğŸ“–['element_ids'] âœï¸['auth_api', 'storage_keys']

âš¡ PHASE 2: EXECUTION (Hyperfocus + Communication)
--------------------------------------------------------------------------------
ğŸ¯ HTML Structure
   âœ“ Generated (1542 chars)

ğŸ¯ CSS Styling
   ğŸ“– Reading context: ['element_ids', 'page_structure']
   âœï¸ Wrote: ['css_classes', 'color_scheme']
   âœ“ Generated (2387 chars)

ğŸ”§ PHASE 3: ASSEMBLY
--------------------------------------------------------------------------------
ğŸ”— Integrating artifacts...

âœ… FINAL RESULT
================================================================================
ğŸ“¦ Library Management System
ğŸ¯ Create a complete library management system with authentication, CRUD, and dashboard

ğŸ“‚ Artifacts: 3
ğŸ§  SharedState Keys: ['element_ids', 'page_structure', 'css_classes', 'color_scheme', 'auth_api']

ğŸ”— Integrated Result:
--------------------------------------------------------------------------------
[Complete integrated system...]
```

## ğŸ”„ State Management

### Shared State

* **Persistent**: Survives restarts
* **Structured**: JSON-serializable dictionary
* **Selective**: Modules access only relevant keys

### Checkpoints

* Architecture saved in `architecture.json`
* Shared state in `shared_state.json`
* Individual artifacts in text files

## ğŸ“¦ Exporting Results

```python
# Full results download
from google.colab import files
!zip -r matrioska_results.zip /content/matrioska_artifacts /content/matrioska_checkpoints
files.download('matrioska_results.zip')
```

## ğŸ› ï¸ Technical Requirements

* **GPU**: NVIDIA T4 (8GB VRAM) or higher
* **RAM**: 16GB+
* **Python**: 3.8+
* **Libraries**: transformers, torch, bitsandbytes, sentencepiece

## ğŸš« Issues and Limitations

* **Model Dependency**: The quality of outputs is linearly dependent on the base model's capabilities. More powerful models (GPT-4, Claude 3, etc.) produce significantly better results, while smaller models may struggle with complex decompositions.

* **Token Consumption**: The modular approach consumes substantially more tokens compared to direct generation. For paid API services (OpenAI, Anthropic, etc.), this can lead to significantly higher costs, making it economically challenging for large-scale projects.

* **Processing Time**: Sequential module execution results in longer processing times compared to single-prompt approaches. The architecture phase + multiple module generations + integration phase creates inherent latency.

* **Project Suitability**: Not recommended for small or simple projects where direct generation would be more efficient. The overhead of architectural decomposition outweighs benefits for basic applications, scripts, or single-component systems.

* **Complexity Overhead**: Introduces additional abstraction layers that may not be justified for straightforward tasks. The shared state management and module coordination add complexity that only pays off in sufficiently complex systems.

* **Error Propagation**: Module dependencies create chain reaction risks - errors in early modules can propagate through subsequent modules, requiring complete regeneration cycles.

* **Integration Challenges**: While shared state helps, final integration still requires careful validation. Module outputs may not always seamlessly combine without manual intervention or additional refinement cycles.

* **Resource Intensive**: Requires significant computational resources for optimal performance, making it less suitable for resource-constrained environments or edge deployment scenarios.

* **Expertise Requirement**: Effective usage requires understanding of both the domain problem and the orchestration system, creating a steeper learning curve compared to direct model interaction.

* **API Rate Limiting**: Multiple sequential API calls may encounter rate limiting issues with commercial providers, potentially disrupting longer orchestration workflows.

## ğŸ”® Roadmap

* [ ] Multi-LLM support
* [ ] Web interface for monitoring
* [ ] Plugin system for custom modules
* [ ] Memory optimization for large projects
* [ ] Integration with version control

## ğŸ“„ License

This project is intended for research and development purposes.

---

**Matrioska**: Transforming complexity into intelligent modularity ğŸª†